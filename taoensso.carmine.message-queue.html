<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>taoensso.carmine.message-queue documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Carmine</span> <span class="project-version">3.4.1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>taoensso</span></div></div></li><li class="depth-2"><a href="taoensso.carmine.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>carmine</span></div></a></li><li class="depth-3 branch"><a href="taoensso.carmine.connections.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>connections</span></div></a></li><li class="depth-3 branch"><a href="taoensso.carmine.locks.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>locks</span></div></a></li><li class="depth-3 branch current"><a href="taoensso.carmine.message-queue.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>message-queue</span></div></a></li><li class="depth-3 branch"><a href="taoensso.carmine.ring.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ring</span></div></a></li><li class="depth-3"><a href="taoensso.carmine.tundra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tundra</span></div></a></li><li class="depth-4 branch"><a href="taoensso.carmine.tundra.carmine.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>carmine</span></div></a></li><li class="depth-4 branch"><a href="taoensso.carmine.tundra.disk.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>disk</span></div></a></li><li class="depth-4 branch"><a href="taoensso.carmine.tundra.faraday.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>faraday</span></div></a></li><li class="depth-4"><a href="taoensso.carmine.tundra.s3.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>s3</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-default-throttle-ms-fn"><div class="inner"><span>default-throttle-ms-fn</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-enqueue"><div class="inner"><span>enqueue</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-exp-backoff"><div class="inner"><span>exp-backoff</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-IWorker"><div class="inner"><span>IWorker</span></div></a></li><li class="depth-2 branch"><a href="taoensso.carmine.message-queue.html#var-start"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>start</span></div></a></li><li class="depth-2"><a href="taoensso.carmine.message-queue.html#var-stop"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stop</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-message-status"><div class="inner"><span>message-status</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-monitor-fn"><div class="inner"><span>monitor-fn</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-queue-content"><div class="inner"><span>queue-content</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-queue-names"><div class="inner"><span>queue-names</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-queue-size"><div class="inner"><span>queue-size</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-queue-status"><div class="inner"><span>queue-status</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-queues-clear.21.21"><div class="inner"><span>queues-clear!!</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-queues-clear-all.21.21.21"><div class="inner"><span>queues-clear-all!!!</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-set-min-log-level.21"><div class="inner"><span>set-min-log-level!</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-worker"><div class="inner"><span>worker</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">taoensso.carmine.message-queue</h1><div class="doc"><pre class="plaintext">Carmine-backed Clojure message queue, v2.
All heavy lifting by Redis.

Uses an optimized message circle architecture that is simple, reliable,
and has pretty good throughput and latency.

See `mq-architecture.svg` in repo for diagram of architecture,
Ref. &lt;<a href="http://antirez.com/post/250">http://antirez.com/post/250</a>&gt; for initial inspiration.

Message status e/o:
  nil                  - Not in queue or already GC'd
  :queued              - Awaiting handler
  :queued-with-backoff - Awaiting handler, but skip until backoff expired
  :locked              - Currently with handler
  :locked-with-requeue - Currently with handler, will requeue when done
  :done-awaiting-gc    - Finished handling, awaiting GC
  :done-with-backoff   - Finished handling, awaiting GC,
                         but skip until dedupe backoff expired
  :done-with-requeue   - Will requeue, but skip until dedupe backoff expired

Redis keys (all prefixed with `carmine:mq:&lt;qname&gt;:`):
  * messages      - hash: {mid mcontent} ; Message content
  * messages-rq   - hash: {mid mcontent} ; '' for requeues
  * lock-times    - hash: {mid lock-ms}  ; Optional mid-specific lock duration
  * lock-times-rq - hash: {mid lock-ms}  ; '' for requeues
  * udts          - hash: {mid  udt-first-enqueued}
  * locks         - hash: {mid    lock-expiry-time} ; Active locks
  * backoffs      - hash: {mid backoff-expiry-time} ; Active backoffs
  * nattempts     - hash: {mid attempt-count}
  * done          - mid set: awaiting gc, etc.
  * requeue       - mid set: awaiting requeue ; Deprecated

  * mids-ready    - list: mids for immediate handling     (push to left, pop from right)
  * mid-circle    - list: mids for maintenance processing (push to left, pop from right)
  * ndry-runs     - int: num times worker(s) have lapped queue w/o work to do

  * isleep-a      - list: 0/1 sentinel element for `interruptible-sleep`
  * isleep-b      - list: 0/1 sentinel element for `interruptible-sleep`</pre></div><div class="public anchor" id="var-default-throttle-ms-fn"><h3>default-throttle-ms-fn</h3><div class="usage"><code>(default-throttle-ms-fn queue-size)</code></div><div class="doc"><pre class="plaintext">Default/example (fn [queue-size]) -&gt; ?throttle-msecs
</pre></div></div><div class="public anchor" id="var-enqueue"><h3>enqueue</h3><div class="usage"><code>(enqueue qname message)</code><code>(enqueue qname message {:keys [init-backoff-ms lock-ms mid can-update? can-requeue?]})</code></div><div class="doc"><pre class="plaintext">Pushes given message (any Clojure data type) to named queue and returns
a map with keys: [success? mid action error].

When `success?` is true:  `mid`, `action` will be present, with
                          `action` e/o #{:added :updated}.

When `success?` is false: `error` will be present, with
                          `error` e/o #{:already-queued :locked :backoff}.

Options:
    `:init-backoff-ms` - Optional initial backoff in msecs.
    `:lock-ms`         - Optional lock time in msecs. When unspecified, the
                         worker's default lock time will be used.

    `:mid`             - Optional unique message id (e.g. message hash) to
                         identify a specific message for dedupe/update/requeue.
                         When unspecified, a random uuid will be used.

    `:can-update?`     - When true, will update message content and/or lock-ms for
                         an mid still awaiting handling.

    `:can-requeue?`    - When true, will mark message with `:locked` or
                         `:done-with-backoff` status so that it will be
                         automatically requeued after garbage collection.</pre></div></div><div class="public anchor" id="var-exp-backoff"><h3>exp-backoff</h3><div class="usage"><code>(exp-backoff n-attempt)</code><code>(exp-backoff n-attempt {:keys [min max factor], :or {factor 1000}})</code></div><div class="doc"><pre class="plaintext">Returns binary exponential backoff value for n&lt;=36.
</pre></div></div><div class="public anchor" id="var-IWorker"><h3>IWorker</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Private, please don't use this.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-start"><h3>start</h3><div class="usage"><code>(start this)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-stop"><h3>stop</h3><div class="usage"><code>(stop this)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div></div><div class="public anchor" id="var-message-status"><h3>message-status</h3><div class="usage"><code>(message-status qname mid)</code></div><div class="doc"><pre class="plaintext">Returns current message status, e/o:
`nil`                  - Not in queue or already GC'd
`:queued`              - Awaiting handler
`:queued-with-backoff` - Awaiting handler, but skip until backoff expired
`:locked`              - Currently with handler
`:locked-with-requeue` - Currently with handler, will requeue when done
`:done-awaiting-gc`    - Finished handling, awaiting GC
`:done-with-backoff`   - Finished handling, awaiting GC,
                         but skip until dedupe backoff expired
`:done-with-requeue`   - Will requeue, but skip until dedupe backoff expired</pre></div></div><div class="public anchor" id="var-monitor-fn"><h3>monitor-fn</h3><div class="usage"><code>(monitor-fn qname max-queue-size warn-backoff-ms)</code></div><div class="doc"><pre class="plaintext">Returns a worker monitor fn that warns when queue exceeds the prescribed
size. A backoff timeout can be provided to rate-limit this warning.</pre></div></div><div class="public anchor" id="var-queue-content"><h3>queue-content</h3><div class="usage"><code>(queue-content conn-opts qname)</code></div><div class="doc"><pre class="plaintext">Returns detailed {&lt;mid&gt; {:keys [message status ...]}} map for every
message currently in queue.

O(n_mids) and expensive, avoid use in production.</pre></div></div><div class="public anchor" id="var-queue-names"><h3>queue-names</h3><div class="usage"><code>(queue-names conn-opts)</code><code>(queue-names conn-opts pattern)</code></div><div class="doc"><pre class="plaintext">Returns a non-empty set of existing queue names, or nil.
Executes a Redis scan command, so O(n) of the number of keys in db.</pre></div></div><div class="public anchor" id="var-queue-size"><h3>queue-size</h3><div class="usage"><code>(queue-size conn-opts qname)</code></div><div class="doc"><pre class="plaintext">Returns in O(1) the approx number of messages awaiting handler for
given named queue. Same as (:nqueued (queue-status conn-opts qname)).</pre></div></div><div class="public anchor" id="var-queue-status"><h3>queue-status</h3><div class="usage"><code>(queue-status conn-opts qname)</code></div><div class="doc"><pre class="plaintext">Returns in O(1) the approx {:keys [nqueued nlocked nbackoff ntotal]}
counts for given named queue.

`nlocked` and `nbackoff` may include expired entries!</pre></div></div><div class="public anchor" id="var-queues-clear.21.21"><h3>queues-clear!!</h3><div class="usage"><code>(queues-clear!! conn-opts qnames)</code></div><div class="doc"><pre class="plaintext">Permanently deletes ALL content for the Carmine message queues with
given names.

Returns nil, or a non-empty vector of the queue names that were cleared.</pre></div></div><div class="public anchor" id="var-queues-clear-all.21.21.21"><h3>queues-clear-all!!!</h3><div class="usage"><code>(queues-clear-all!!! conn-opts)</code></div><div class="doc"><pre class="plaintext">**DANGER**!
Permanently deletes ALL content for *ALL* Carmine message queues.
Returns nil, or a non-empty vector of the queue names that were cleared.</pre></div></div><div class="public anchor" id="var-set-min-log-level.21"><h3>set-min-log-level!</h3><div class="usage"><code>(set-min-log-level! level)</code></div><div class="doc"><pre class="plaintext">Sets Timbre's minimum log level for internal Carmine message queue namespaces.
Possible levels: #{:trace :debug :info :warn :error :fatal :report}.
Default level: `:info`.</pre></div></div><div class="public anchor" id="var-worker"><h3>worker</h3><div class="usage"><code>(worker conn-opts qname)</code><code>(worker conn-opts qname {:keys [handler monitor lock-ms eoq-backoff-ms throttle-ms auto-start nthreads-worker nthreads-handler], :as worker-opts, :or {handler (fn [m] (timbre/info m) {:status :success}), monitor (monitor-fn qname 1000 (enc/ms :hours 6)), lock-ms (enc/ms :mins 60), nthreads-worker 1, nthreads-handler 1, throttle-ms default-throttle-ms-fn, eoq-backoff-ms exp-backoff, auto-start true}})</code></div><div class="doc"><pre class="plaintext">Returns a stateful threaded `CarmineMessageQueueWorker` to handle messages
added to named queue with `enqueue`.

API:
  - (deref &lt;worker&gt;)          =&gt; Detailed worker status map (see "Debugging" below).
  - (&lt;worker&gt; :start)         =&gt; Same as calling (start &lt;worker&gt;).
  - (&lt;worker&gt; :stop)          =&gt; Same as calling (stop  &lt;worker&gt;).
  - (&lt;worker&gt; :queue-size)    =&gt; Same as calling `queue-size`    for given qname.
  - (&lt;worker&gt; :queue-status)  =&gt; Same as calling `queue-status`  for given qname.
  - (&lt;worker&gt; :queue-content) =&gt; Same as calling `queue-content` for given qname.

Debugging:

  To debug a worker, deref it to see detailed status map with keys:
    `:qname`     - Worker's queue name (string)
    `:opts`      - Worker's            options map
    `:conn-opts` - Worker's connection options map
    `:running?`  - Is the worker currently running? (true/false)
    `:nthreads`  - {:keys [worker handler]}
    `:stats`
      `:queue-size`        - {:keys [last min max mean mad var p50 p90 ...]}
      `:queueing-time-ms`  - {:keys [last min max mean mad var p50 p90 ...]}
      `:handling-time-ns`  - {:keys [last min max mean mad var p50 p90 ...]}
      `:counts`
        `:handler/success` - Number of handler calls with `:success` status
        `:handler/error`   - Number of handler calls with `:error`   status
        `:handler/retry`   - Number of handler calls with `:retry`   status
        `:handler/backoff` - Number of handler calls encountering an mid in backoff
        ...

  See also the `:monitor` option below, and utils:
    `queue-names`, `queue-size`, `queue-content`, `message-status`, etc.

Options:

  `:handler`
    (fn [{:keys [qname mid message attempt]}]) called for each worker message.
    Should return a map with possible keys:
      `:status`     - ∈ {:success :error :retry}
      `:throwable`  - Optional Throwable when relevant
      `:backoff-ms` - Optional time (in milliseconds) to backoff
                      for dedupe or before retrying

    If handler throws ANY `Throwable`, will assume `:error` status and NOT retry.
    For custom error handling, make sure to use an appropriate try/catch
    within your handler fn!

  `:monitor` - (fn [{:keys [queue-size ndry-runs poll-reply]}])
    Called on each worker loop iteration. Useful for queue monitoring/logging.
    See also `monitor-fn`.

  `:lock-ms` (default 60 minutes)
    Default time (in milliseconds) that handler may keep a message before handler
    is considered fatally stalled and message is re-queued. Must be large enough
    to prevent double handling!

    Can be overridden on a per-message basis via `enqueue`.

  `:throttle-ms` (default `default-throttle-ms-fn`)
    Thread sleep period (in milliseconds) between each poll.
    Can be a (fn [queue-size]) -&gt; ?sleep-msecs.

  `:eoq-backoff-ms` (default `exp-backoff`)
    Max time (in milliseconds) to sleep thread each time end of queue is reached.
    Can be a (fn [ndry-runs]) -&gt; msecs for n&lt;=5.
    Sleep may be interrupted when new messages are enqueued.
    If present, connection read timeout should be &gt;= max msecs!

  `:nthreads-worker`  - Number of threads to monitor and maintain queue.
  `:nthreads-handler` - Number of threads to handle queue messages with handler fn.</pre></div></div></div></body></html>