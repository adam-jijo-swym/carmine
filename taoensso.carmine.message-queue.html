<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>taoensso.carmine.message-queue documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Carmine</span> <span class="project-version">3.3.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>taoensso</span></div></div></li><li class="depth-2"><a href="taoensso.carmine.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>carmine</span></div></a></li><li class="depth-3 branch"><a href="taoensso.carmine.connections.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>connections</span></div></a></li><li class="depth-3 branch"><a href="taoensso.carmine.locks.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>locks</span></div></a></li><li class="depth-3 branch current"><a href="taoensso.carmine.message-queue.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>message-queue</span></div></a></li><li class="depth-3 branch"><a href="taoensso.carmine.ring.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ring</span></div></a></li><li class="depth-3"><a href="taoensso.carmine.tundra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tundra</span></div></a></li><li class="depth-4 branch"><a href="taoensso.carmine.tundra.carmine.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>carmine</span></div></a></li><li class="depth-4 branch"><a href="taoensso.carmine.tundra.disk.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>disk</span></div></a></li><li class="depth-4 branch"><a href="taoensso.carmine.tundra.faraday.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>faraday</span></div></a></li><li class="depth-4"><a href="taoensso.carmine.tundra.s3.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>s3</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-default-throttle-ms-fn"><div class="inner"><span>default-throttle-ms-fn</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-enqueue"><div class="inner"><span>enqueue</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-exp-backoff"><div class="inner"><span>exp-backoff</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-IWorker"><div class="inner"><span>IWorker</span></div></a></li><li class="depth-2 branch"><a href="taoensso.carmine.message-queue.html#var-start"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>start</span></div></a></li><li class="depth-2"><a href="taoensso.carmine.message-queue.html#var-stop"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stop</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-lua-dequeue_"><div class="inner"><span>lua-dequeue_</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-lua-enqueue_"><div class="inner"><span>lua-enqueue_</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-lua-msg-status_"><div class="inner"><span>lua-msg-status_</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-message-status"><div class="inner"><span>message-status</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-monitor-fn"><div class="inner"><span>monitor-fn</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-queue-content"><div class="inner"><span>queue-content</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-queue-names"><div class="inner"><span>queue-names</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-queue-size"><div class="inner"><span>queue-size</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-queue-status"><div class="inner"><span>queue-status</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-queues-clear.21.21"><div class="inner"><span>queues-clear!!</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-queues-clear-all.21.21.21"><div class="inner"><span>queues-clear-all!!!</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-set-min-log-level.21"><div class="inner"><span>set-min-log-level!</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-worker"><div class="inner"><span>worker</span></div></a></li><li class="depth-1"><a href="taoensso.carmine.message-queue.html#var-worker.3F"><div class="inner"><span>worker?</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">taoensso.carmine.message-queue</h1><div class="doc"><pre class="plaintext">Carmine-backed Clojure message queue, v2.
All heavy lifting by Redis.

Uses an optimized message circle architecture that is simple, reliable,
and has pretty good throughput and latency.

See `mq-diagram.svg` in repo for diagram of architecture,
Ref. <a href="http://antirez.com/post/250">http://antirez.com/post/250</a> for initial inspiration.

Message status e/o:
  nil                  - Not in queue or already GC'd
  :queued              - Awaiting handler
  :queued-with-backoff - Awaiting handler, but skip until backoff expired
  :locked              - Currently with handler
  :locked-with-requeue - Currently with handler, will requeue when done
  :done-awaiting-gc    - Finished handling, awaiting GC
  :done-with-backoff   - Finished handling, awaiting GC,
                         but skip until dedupe backoff expired
  :done-with-requeue   - Will requeue, but skip until dedupe backoff expired

Redis keys (all prefixed with `carmine:mq:&lt;qname&gt;:`):
  * messages      - hash: {mid mcontent} ; Message content
  * messages-rq   - hash: {mid mcontent} ; '' for requeues
  * lock-times    - hash: {mid lock-ms}  ; Optional mid-specific lock duration
  * lock-times-rq - hash: {mid lock-ms}  ; '' for requeues
  * udts          - hash: {mid  udt-first-enqueued}
  * locks         - hash: {mid    lock-expiry-time} ; Active locks
  * backoffs      - hash: {mid backoff-expiry-time} ; Active backoffs
  * nattempts     - hash: {mid attempt-count}
  * done          - mid set: awaiting gc, etc.
  * requeue       - mid set: awaiting requeue ; Deprecated

  * mids-ready    - list: mids for immediate handling     (push to left, pop from right)
  * mid-circle    - list: mids for maintenance processing (push to left, pop from right)
  * ndry-runs     - int: num times worker(s) have lapped queue w/o work to do

  * isleep-a      - list: 0/1 sentinel element for `interruptible-sleep`
  * isleep-b      - list: 0/1 sentinel element for `interruptible-sleep`</pre></div><div class="public anchor" id="var-default-throttle-ms-fn"><h3>default-throttle-ms-fn</h3><div class="usage"><code>(default-throttle-ms-fn queue-size)</code></div><div class="doc"><pre class="plaintext">Default/example (fn [queue-size]) -&gt; ?throttle-msecs
</pre></div></div><div class="public anchor" id="var-enqueue"><h3>enqueue</h3><div class="usage"><code>(enqueue qname message)</code><code>(enqueue qname message {:keys [init-backoff-ms lock-ms mid can-update? can-requeue?]})</code></div><div class="doc"><pre class="plaintext">Pushes given message (any Clojure data type) to named queue and returns
a map with keys: [success? mid action error].

When `success?` is true:  `mid`, `action` will be present, with
                          `action` e/o #{:added :updated}.

When `success?` is false: `error` will be present, with
                          `error` e/o #{:already-queued :locked :backoff}.

Options:
    :init-backoff-ms - Optional initial backoff in msecs.
    :lock-ms         - Optional lock time in msecs. When unspecified, the
                       worker's default lock time will be used.

    :mid             - Optional unique message id (e.g. message hash) to
                       identify a specific message for dedupe/update/requeue.
                       When unspecified, a random uuid will be used.

    :can-update?     - When true, will update message content and/or lock-ms for
                       an mid still awaiting handling.
    :can-requeue?    - When true, will mark message with `:locked` or
                       `:done-with-backoff` status so that it will be
                       automatically requeued after garbage collection.</pre></div></div><div class="public anchor" id="var-exp-backoff"><h3>exp-backoff</h3><div class="usage"><code>(exp-backoff n-attempt)</code><code>(exp-backoff n-attempt {:keys [min max factor], :or {factor 1000}})</code></div><div class="doc"><pre class="plaintext">Returns binary exponential backoff value for n&lt;=36.
</pre></div></div><div class="public anchor" id="var-IWorker"><h3>IWorker</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Implementation detail.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-start"><h3>start</h3><div class="usage"><code>(start this)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-stop"><h3>stop</h3><div class="usage"><code>(stop this)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div></div><div class="public anchor" id="var-lua-dequeue_"><h3>lua-dequeue_</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-lua-enqueue_"><h3>lua-enqueue_</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-lua-msg-status_"><h3>lua-msg-status_</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-message-status"><h3>message-status</h3><div class="usage"><code>(message-status qname mid)</code></div><div class="doc"><pre class="plaintext">Returns current message status, e/o:
nil                  - Not in queue or already GC'd
:queued              - Awaiting handler
:queued-with-backoff - Awaiting handler, but skip until backoff expired
:locked              - Currently with handler
:locked-with-requeue - Currently with handler, will requeue when done
:done-awaiting-gc    - Finished handling, awaiting GC
:done-with-backoff   - Finished handling, awaiting GC,
                       but skip until dedupe backoff expired
:done-with-requeue   - Will requeue, but skip until dedupe backoff expired</pre></div></div><div class="public anchor" id="var-monitor-fn"><h3>monitor-fn</h3><div class="usage"><code>(monitor-fn qname max-queue-size warn-backoff-ms)</code></div><div class="doc"><pre class="plaintext">Returns a worker monitor fn that warns when queue exceeds the prescribed
size. A backoff timeout can be provided to rate-limit this warning.</pre></div></div><div class="public anchor" id="var-queue-content"><h3>queue-content</h3><div class="usage"><code>(queue-content conn-opts qname)</code></div><div class="doc"><pre class="plaintext">Returns detailed {&lt;mid&gt; {:keys [message status ...]}} map for every
message currently in queue.

O(n_mids) and expensive, avoid use in production.</pre></div></div><div class="public anchor" id="var-queue-names"><h3>queue-names</h3><div class="usage"><code>(queue-names conn-opts)</code><code>(queue-names conn-opts pattern)</code></div><div class="doc"><pre class="plaintext">Returns a non-empty set of existing queue names, or nil.
</pre></div></div><div class="public anchor" id="var-queue-size"><h3>queue-size</h3><div class="usage"><code>(queue-size conn-opts qname)</code></div><div class="doc"><pre class="plaintext">Returns in O(1) the approx number of messages awaiting handler for
given named queue. Same as (:nqueued (queue-status conn-opts qname)).</pre></div></div><div class="public anchor" id="var-queue-status"><h3>queue-status</h3><div class="usage"><code>(queue-status conn-opts qname)</code></div><div class="doc"><pre class="plaintext">Returns in O(1) the approx {:keys [nqueued nlocked nbackoff ntotal]}
counts for given named queue.

`nlocked` and `nbackoff` may include expired entries!</pre></div></div><div class="public anchor" id="var-queues-clear.21.21"><h3>queues-clear!!</h3><div class="usage"><code>(queues-clear!! conn-opts qnames)</code></div><div class="doc"><pre class="plaintext">Permanently deletes ALL content for the Carmine message queues with
given names.

Returns nil, or a non-empty vector of the queue names that were cleared.</pre></div></div><div class="public anchor" id="var-queues-clear-all.21.21.21"><h3>queues-clear-all!!!</h3><div class="usage"><code>(queues-clear-all!!! conn-opts)</code></div><div class="doc"><pre class="plaintext">**DANGER**!
Permanently deletes ALL content for *ALL* Carmine message queues.
Returns nil, or a non-empty vector of the queue names that were cleared.</pre></div></div><div class="public anchor" id="var-set-min-log-level.21"><h3>set-min-log-level!</h3><div class="usage"><code>(set-min-log-level! level)</code></div><div class="doc"><pre class="plaintext">Sets Timbre's minimum log level for internal Carmine message queue namespaces.
Possible levels: #{:trace :debug :info :warn :error :fatal :report}.
Default level: `:info`.</pre></div></div><div class="public anchor" id="var-worker"><h3>worker</h3><div class="usage"><code>(worker conn-opts qname)</code><code>(worker conn-opts qname {:keys [handler monitor lock-ms eoq-backoff-ms throttle-ms auto-start nthreads-worker nthreads-handler], :as worker-opts, :or {handler (fn [m] (timbre/info m) {:status :success}), monitor (monitor-fn qname 1000 (enc/ms :hours 6)), lock-ms (enc/ms :mins 60), nthreads-worker 1, nthreads-handler 1, throttle-ms :auto, eoq-backoff-ms exp-backoff, auto-start true}})</code></div><div class="doc"><pre class="plaintext">Returns a stateful threaded CarmineMessageQueueWorker to handle messages
added to named queue with `enqueue`.

API:
  - (deref &lt;worker&gt;)          =&gt; Status map, {:keys [running? nthreads stats ...]}.
  - (&lt;worker&gt; :start)         =&gt; Same as calling (start &lt;worker&gt;).
  - (&lt;worker&gt; :stop)          =&gt; Same as calling (stop  &lt;worker&gt;).
  - (&lt;worker&gt; :queue-size)    =&gt; Same as calling `queue-size`    for given qname.
  - (&lt;worker&gt; :queue-status)  =&gt; Same as calling `queue-status`  for given qname.
  - (&lt;worker&gt; :queue-content) =&gt; Same as calling `queue-content` for given qname.

Options:
  :handler          - (fn [{:keys [qname mid message attempt]}]) that throws
                      or returns {:status     &lt;#{:success :error :retry}&gt;
                                  :throwable  &lt;Throwable&gt;
                                  :backoff-ms &lt;retry-or-dedupe-backoff-ms}.
  :monitor          - (fn [{:keys [queue-size ndry-runs poll-reply]}])
                      called on each worker loop iteration. Useful for queue
                      monitoring/logging. See also `monitor-fn`.
  :lock-ms          - Default time that handler may keep a message before handler
                      considered fatally stalled and message is re-queued. Must be
                      sufficiently high to prevent double handling. Can be
                      overridden on a per-message basis via `enqueue`.

  :throttle-ms      - Thread sleep period between each poll.
                      Can be a (fn [queue-size]) -&gt; ?sleep-msecs,
                      or :auto (to use `default-throttle-ms-fn`).

  :eoq-backoff-ms   - Max msecs to sleep thread each time end of queue is reached.
                      Can be a (fn [ndry-runs]) -&gt; msecs for n&lt;=5.
                      Sleep may be interrupted when new messages are enqueued.
                      If present, connection read timeout should be &gt;= max msecs.

  :nthreads-worker  - Number of threads to monitor and maintain queue.
  :nthreads-handler - Number of threads to handle queue messages with handler fn.</pre></div></div><div class="public anchor" id="var-worker.3F"><h3>worker?</h3><div class="usage"><code>(worker? x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></body></html>