(ns taoensso.carmine-v4.sentinel
  "Private ns, implementation detail.

  Implementation of the Redis Sentinel protocol,
  Ref. https://redis.io/docs/reference/sentinel-clients/

  A set of Sentinel servers (usu. >= 3) basically provides a
  quorum mechanism to resolve the current master Redis server
  for a given \"master name\" (service name):

    (fn resolve-redis-master
      [master-name stateful-sentinel-addresses]) -> <redis-master-address>

  Requests to the service then go through an indirection step:
    request -> resolve-redis-master -> redis-master"

  {:author "Peter Taoussanis (@ptaoussanis)"}
  (:require
   [clojure.test    :as test :refer [deftest testing is]]
   [taoensso.encore :as enc  :refer [have have? throws?]]
   [taoensso.carmine-v4.utils :as utils]
   [taoensso.carmine-v4.conns :as conns]
   [taoensso.carmine-v4.resp  :as resp]
   [taoensso.carmine-v4.opts  :as opts]))

(comment
  (remove-ns      'taoensso.carmine-v4.sentinel)
  (test/run-tests 'taoensso.carmine-v4.sentinel))

;;;; Dev/test config

(defn- spit-sentinel-test-config
  [{:keys [n-sentinels first-sentinel-port master-name master-addr quorum]
    :or   {n-sentinels 2
           first-sentinel-port 26379
           master-name "my-master"
           master-addr ["127.0.0.1" 6379]
           quorum n-sentinels}}]

  (dotimes [idx n-sentinels]
    (let [[master-ip master-port] master-addr
          sentinel-port (+ first-sentinel-port idx)
          fname (str "sentinel" (inc idx) ".conf")

          content
          (format
            "# Redis Sentinel test config generated by Carmine
# Start Sentinel server with `redis-sentinel %1$s`

port %2$s

# sentinel monitor <master-group-name> <ip> <port> <quorum>
sentinel monitor %3$s %4$s %5$s %6$s
sentinel down-after-milliseconds %3$s 60000"

            fname
            sentinel-port
            master-name master-ip master-port
            quorum)]

      (spit fname content ))))

(comment (spit-sentinel-test-config {}))

;;;; Sentinel spec maps
;; {<master-name> [[<sentinel-server-ip> <sentinel-server-port>] ...]}

(defn- remove-sentinel [old-addrs addr]
  (let [addr (opts/parse-sock-addr addr)]
    (transduce (remove #(= % addr)) conj [] old-addrs)))

(defn- add-sentinel->front [old-addrs addr]
  (let [addr (opts/parse-sock-addr addr)]
    (if (= (get old-addrs 0) addr)
      old-addrs
      (transduce (remove #(= % addr))
        conj [addr] old-addrs))))

(defn- add-sentinels->back [old-addrs addrs]
  (if (empty? addrs)
    old-addrs
    (let [old-addrs   (or  old-addrs [])
          old-addr?   (set old-addrs)]
      (transduce (comp (map opts/parse-sock-addr) (remove old-addr?))
        conj old-addrs addrs))))

(defn- clean-sentinel-spec [spec-map]
  (reduce-kv
    (fn [m master-name addrs]
      (assoc m (enc/as-qname master-name)
        (transduce (comp (map opts/parse-sock-addr) (distinct))
          conj [] addrs)))
    {} spec-map))

(deftest ^:private _spec-map-utils
  [(let [sm (add-sentinels->back nil [["ip1" 1] ["ip2" "2"] ^{:server-name "server3"} ["ip3" 3]])
         sm (add-sentinel->front sm  ["ip2" 2])
         sm (add-sentinels->back sm [["ip3" 3] ["ip6" 6]])]

     [(is (= sm [["ip2" 2] ["ip1" 1] ["ip3" 3] ["ip6" 6]]))
      (is (= (mapv opts/descr-sock-addr sm)
            [["ip2" 2] ["ip1" 1] ["ip3" 3 {:server-name "server3"}] ["ip6" 6]]))])

   (let [sm (add-sentinels->back nil [["ip4" 4] ["ip5" "5"]])
         sm (remove-sentinel     sm  ["ip4" 4])]
     [(is (= sm [["ip5" 5]]))])

   (let [sm (clean-sentinel-spec {:m1 [^:my-meta ["ip1" 1] ["ip1" "1"] ["ip2" "2"]]})]
     [(is (= sm {"m1" [["ip1" 1] ["ip2" 2]]}))
      (is (= (mapv opts/descr-sock-addr (get sm "m1"))
            [["ip1" 1 {:my-meta true}] ["ip2" 2]]))])])

;;;; Sentinel Specs
;; Simple stateful agent wrapper around a sentinel spec map

(defprotocol ^:private ISentinelSpec
  "Internal protocol, not for public use or extension."
  (^:private get-sentinels        [spec     master-name])
  (^:private update-sentinels!    [spec cbs master-name f])
  (^:private add-sentinels->back! [spec cbs master-name addrs])
  (^:private add-sentinel->front! [spec cbs master-name addr])
  (^:private remove-sentinel!     [spec cbs master-name addr])
  (^:private reset-master!        [spec cbs master-name addr]))

(deftype SentinelSpec
  [sentinel-opts
   spec-map_ ; {<master-name> [[<sentinel-ip> <sentinel-port>] ...]} delay
   resolved_ ; {<master-name> [<redis-ip> <redis-port>]}
   ]

  Object (toString [this] (str "SentinelSpec[" (binding [*print-readably* false] (pr-str @this)) "]"))
  clojure.lang.IDeref
  (deref [this]
    {:sentinel-opts sentinel-opts
     :spec-map (force @spec-map_)
     :resolved @resolved_})

  ISentinelSpec
  (get-sentinels     [_        master-name  ] (get (force @spec-map_) (enc/as-qname master-name)))
  (update-sentinels! [this cbs master-name f]
    (let [master-name (enc/as-qname master-name)
          [old-sm_ new-sm_]
          (swap-vals! spec-map_
            (fn [sm_]
              (delay ; To minimize contention during expensive updates
                (let [sm        (force sm_)
                      old-addrs (get   sm master-name)
                      new-addrs (f old-addrs)]
                  (assoc sm master-name new-addrs)))))

          old (get (force old-sm_) master-name)
          new (get (deref new-sm_) master-name)]

      (if (= old new)
        false
        (do
          (utils/cb-notify!
            (get-in cbs [:private :on-sentinels-change])
            (get-in cbs [:user    :on-sentinels-change])
            (delay
              {:cbid :sentinels-changed
               :master-name master-name
               :sentinels   {:old old, :new new}
               :spec-state  @this}))
          true))))

  (add-sentinels->back! [this cbs master-name addrs] (update-sentinels! this cbs master-name #(add-sentinels->back % addrs)))
  (add-sentinel->front! [this cbs master-name addr]  (update-sentinels! this cbs master-name #(add-sentinel->front % addr)))
  (remove-sentinel!     [this cbs master-name addr]  (update-sentinels! this cbs master-name #(remove-sentinel     % addr)))
  (reset-master!        [this cbs master-name addr]
    (let [master-name (enc/as-qname master-name)
          new-addr    (opts/parse-sock-addr addr)
          old-addr    (enc/reset-val! resolved_ master-name new-addr)]

      (if (= new-addr old-addr)
        false
        (do
          (utils/cb-notify!
            (get-in cbs [:private :on-master-change])
            (get-in cbs [:user    :on-master-change])
            (delay
              {:cbid :master-changed
               :master-name master-name
               :master-addr {:old old-addr :new new-addr}
               :spec-state  @this}))
          true)))))

(let [ns *ns*] (defmethod print-method SentinelSpec [^SentinelSpec spec ^java.io.Writer w] (.write w (str "#" ns "." spec))))

(defn ^:public sentinel-spec?
  "Returns true iff given argument is a Carmine SentinelSpec."
  [x] (instance? SentinelSpec x))

(defn ^:public sentinel-spec
  "Given a Redis Sentinel server spec map of form
    {<master-name> [[<sentinel-server-ip> <sentinel-server-port>] ...]},
  returns a new stateful SentinelSpec for use in `conn-opts`.

  [ip port] address vecs can have metadata (useful for storing server
  names, etc.). Metadata will be included in relevant error messages.

    (def my-sentinel-spec
      \"Stateful Redis Sentinel server spec. Will be kept
       automatically updated by Carmine.\"
      (sentinel-spec
        {:caching       [^{:server-name \"sentinel1\"} [\"192.158.1.38\" 26379] ...]
         :message-queue [^{:server-name \"sentinel1\"} [\"192.158.1.38\" 26379] ...]}))
      => stateful SentinelSpec

  For options docs, see `carmine/*default-sentinel-opts*` docstring."

  ([spec-map              ] (sentinel-spec spec-map nil))
  ([spec-map sentinel-opts]
   (SentinelSpec.
     (have [:or nil? map?] sentinel-opts)
     (atom (clean-sentinel-spec (have map? spec-map)))
     (atom {}))))

(deftest ^:private _spec-protocol
  [(is (enc/submap? @(sentinel-spec {:m1 [["ip1" "1"] ["ip1" "1"] ["ip2" "2"]]})
         {:spec-map {"m1" [["ip1" 1] ["ip2" 2]]}}))

   (let [sp (sentinel-spec {:m1 [["ip1" "1"] ["ip1" "1"] ["ip2" "2"]]})]
     (add-sentinel->front! sp nil :m1 ["ip3" "3"])
     (add-sentinels->back! sp nil :m1 [["ip4" "4"] ["ip5" "5"]])
     (remove-sentinel!     sp nil :m1 ["ip5" "5"])
     (is (enc/submap?     @sp
           {:spec-map {"m1" [["ip3" 3] ["ip1" 1] ["ip2" 2] ["ip4" 4]]}})))])

(defn- kvs->map [x] (if (map? x) x (into {} (comp (partition-all 2)) x)))
(comment [(kvs->map {"a" "A" "b" "B"}) (kvs->map ["a" "A" "b" "B"])])

(defn resolve-master
  "Given a SentinelSpec and requested master name, returns
  [<master-ip> <master-port>] as reported by Sentinel consensus, or throws.

  Follows resolution procedure as per Sentinel spec,
  Ref. https://redis.io/docs/reference/sentinel-clients/

  Options will be the nested merge of the following in descending order:
    - `sentinel-opts` provided here.
    - `sentinel-opts` provided when creating `sentinel-sepc`.
    - `carmine/*default-sentinel-opts*`.

  For options docs, see `carmine/*default-sentinel-opts*` docstring."
  [master-name sentinel-spec sentinel-opts]

  (let [t0 (System/currentTimeMillis)

        ^SentinelSpec    sentinel-spec (have sentinel-spec? sentinel-spec)
        init-spec-state @sentinel-spec ; {:keys [spec-map sentinel-opts]}

        {:keys [private-cbs]} sentinel-opts
        sentinel-opts
        (opts/parse-sentinel-opts :with-dynamic-default
          (get init-spec-state :sentinel-opts)
          (dissoc sentinel-opts :private-cbs))

        ;; private-cbs for internal use (e.g. by connection manager),
        ;; vals need not be vars!
        cbs {:private private-cbs :user (get sentinel-opts :cbs)}

        master-name (enc/as-qname master-name)
        sentinels   (utils/get-at init-spec-state :spec-map master-name)]

    (if (empty? sentinels)

      (utils/cb-notify-and-throw! :resolve-error
        (utils/get-at cbs :private :on-error)
        (utils/get-at cbs :user    :on-error)
        (ex-info "[Carmine] [Sentinel] No Sentinel servers configured for requested master"
          {:eid :carmine.sentinel/no-sentinels-in-spec
           :master-name   master-name
           :spec-state    init-spec-state
           :sentinel-opts sentinel-opts}
          (Exception. "No sentinel servers in spec")))

      (let [n-attempts* (java.util.concurrent.atomic.AtomicLong. 0)
            {:keys [conn-opts add-missing-sentinels?]} sentinel-opts

            attempt-log_  (volatile! []) ; [<debug-entry> ...]
            error-counts_ (volatile! {}) ; {<sentinel> {:keys [unreachable ignorant misidentified]}}
            record-error!
            (fn [sentinel t0-attempt error-kind ?data]

              ;; Add entry to attempt log
              (let [attempt-ms (- (System/currentTimeMillis) t0-attempt)]
                (vswap! attempt-log_ conj
                  (assoc
                    (conj
                      {:attempt  (.get n-attempts*)
                       :sentinel (opts/descr-sock-addr sentinel)
                       :error    error-kind}
                      ?data)
                    :attempt-ms attempt-ms)))

              ;; Increment counter for error kind
              (vswap! error-counts_
                (fn [m]
                  (enc/update-in m [sentinel error-kind]
                    (fn [?n] (inc ^long (or ?n 0)))))))

            ;; All sentinels reported during resolution process
            reported-sentinels_ (volatile! #{}) ; #{[ip port]}
            complete!
            (fn [?master ?error]
              (update-sentinels! sentinel-spec cbs master-name
                (fn [addrs]
                  (cond-> addrs
                    ?master                (add-sentinel->front ?master)
                    add-missing-sentinels? (add-sentinels->back @reported-sentinels_))))

              (if-let [error ?error]
                (utils/cb-notify-and-throw! :resolve-error
                  (utils/get-at cbs :private :on-error)
                  (utils/get-at cbs :user    :on-error)
                  error)
                (do
                  (utils/cb-notify!
                    (utils/get-at cbs :private :on-success)
                    (utils/get-at cbs :user    :on-success)
                    (delay
                      {:cbid :resolve-success
                       :master-name   master-name
                       :spec-state    init-spec-state
                       :sentinel-opts sentinel-opts
                       :resolved-addr ?master
                       :ms-elapsed (- (System/currentTimeMillis) t0)}))

                  (reset-master! sentinel-spec cbs master-name ?master)
                  (do                                          ?master))))]

        (loop [n-retries 0]

          (let [t0-attempt (System/currentTimeMillis)
                [?sentinel ?master] ; ?[<addr> <addr>]
                (reduce
                  ;; Try each known sentinel, sequentially
                  (fn [acc sentinel]
                    (.incrementAndGet n-attempts*)
                    (let [[ip port] (opts/descr-sock-addr sentinel)
                          [?master ?sentinels-info]
                          (case ip
                            "unreachable"   [::unreachable                 nil]
                            "misidentified" [["simulated-misidentified" 0] nil]
                            "ignorant"      nil
                            (try
                              (conns/with-new-conn ip port conn-opts
                                (fn [_ in out]
                                  (resp/with-replies in out :natural-reads :as-vec
                                    (fn []

                                      ;; Does this sentinel know the master?
                                      (resp/redis-call "SENTINEL" "get-master-addr-by-name"
                                        master-name)

                                      (when add-missing-sentinels?
                                        ;; Ask sentinel to report on other known sentinels
                                        (resp/redis-call "SENTINEL" "sentinels" master-name))))))

                              (catch Throwable _
                                [::unreachable nil])))]

                      (when-let [sentinels-info ?sentinels-info] ; [<sentinel1-info> ...]
                        (enc/run!
                          (fn [info] ; Info may be map (RESP3) or kvseq (RESP2)
                            (let [info (kvs->map info)]
                              (enc/when-let [ip   (get info "ip")
                                             port (get info "port")]
                                (vswap! reported-sentinels_ conj [ip port]))))
                          sentinels-info))

                      (enc/cond
                        (vector?    ?master)               (reduced [sentinel (opts/parse-sock-addr ?master)])
                        (nil?       ?master)               (do (record-error! sentinel t0-attempt :ignorant    nil) acc)
                        (identical? ?master ::unreachable) (do (record-error! sentinel t0-attempt :unreachable nil) acc))))

                  nil sentinels)

                ?resolved-master
                (enc/when-let [sentinel ?sentinel
                               master   ?master]
                  (let [role
                        (let [[ip port] master
                              reply
                              (try
                                (conns/with-new-conn ip port conn-opts
                                  (fn [_ in out]
                                    (resp/with-replies in out :natural-reads :as-vec
                                      (fn [] (resp/redis-call "ROLE")))))
                                (catch Throwable _ nil))]

                          (when (vector? reply) (get reply 0)))]

                    ;; Confirm that master designated by sentinel actually identifies itself as master
                    (if (= role "master")
                      master
                      (do
                        (record-error! sentinel t0-attempt :misidentified
                          {:identified master :actual-role role})
                        false))))]

            (if-let [resolved-master ?resolved-master]
              (complete! resolved-master nil)

              (let [{:keys [timeout-ms retry-delay-ms]} sentinel-opts
                    elapsed-ms  (- (System/currentTimeMillis) t0)
                    retry-at-ms (+ elapsed-ms retry-delay-ms)]

                (if (> retry-at-ms timeout-ms)
                  (do
                    (vswap! attempt-log_ conj
                      [:timeout
                       (str
                         "(" elapsed-ms " elapsed + " retry-delay-ms " delay = " retry-at-ms
                         ") > " timeout-ms " timeout")])

                    (complete! nil
                      (ex-info "[Carmine] [Sentinel] Timed out while trying to resolve requested master"
                        {:eid :carmine.sentinel/resolve-timeout
                         :master-name     master-name
                         :spec-state      init-spec-state
                         :sentinel-opts   sentinel-opts
                         :n-attempts      (.get n-attempts*)
                         :n-retries       n-retries
                         :ms-elapsed      (- (System/currentTimeMillis) t0)
                         :sentinel-errors @error-counts_
                         :attempt-log     @attempt-log_})))
                  (do
                    (vswap! attempt-log_ conj [:retry-after-sleep retry-delay-ms])
                    (Thread/sleep retry-delay-ms)
                    (recur (inc n-retries))))))))))))

(comment
  ;; Use ip e/o #{"unreachable" "ignorant" "misidentified"} to simulate errors
  (resolve-master {}
    {"my-master" [^:my-meta ["ignorant" #_"misidentified" #_"127.0.0.1" 26379]]}
    "my-master")

  (core/wcar {:ip "127.0.0.1" :port "6379"}
    (core/redis-call "ROLE"))

  (core/wcar {:port 26379}
    (core/redis-call "SENTINEL" "get-master-addr-by-name" "my-master"))

  (core/wcar {:port 26379}
    (core/redis-call "HELLO" 3)
    (binding [core/*keywordize-maps?* false]
      (core/redis-call "SENTINEL" "sentinels" "my-master"))))
